this.createjs = this.createjs || {};

(function () {
    'use strict';


    function DisplayObject () {
        this.EventDispatcher_constructor();


        this.alpha = 1;


        this.cacheCanvas = null;


        this.bitmapCache = null;


        this.id = createjs.UID.get();


        this.mouseEnabled = true;


        this.tickEnabled = true;


        this.name = null;


        this.parent = null;


        this.regX = 0;


        this.regY = 0;


        this.rotation = 0;


        this.scaleX = 1;


        this.scaleY = 1;


        this.skewX = 0;


        this.skewY = 0;


        this.shadow = null;


        this.visible = true;


        this.x = 0;


        this.y = 0;


        this.transformMatrix = null;


        this.compositeOperation = null;


        this.snapToPixel = true;


        this.filters = null;


        this.mask = null;


        this.hitArea = null;


        this.cursor = null;


        this._props = new createjs.DisplayProps();


        this._rectangle = new createjs.Rectangle();


        this._bounds = null;


        this._webGLRenderStyle = DisplayObject._StageGL_NONE;


        this._glMtx = new createjs.Matrix2D();
    }

    var p = createjs.extend(DisplayObject, createjs.EventDispatcher);


    DisplayObject._MOUSE_EVENTS = ['click', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'pressmove', 'pressup', 'rollout', 'rollover'];


    DisplayObject.suppressCrossDomainErrors = false;


    DisplayObject._snapToPixelEnabled = false;


    DisplayObject._StageGL_NONE = 0;


    DisplayObject._StageGL_SPRITE = 1;


    DisplayObject._StageGL_BITMAP = 2;


    var canvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
    if (canvas.getContext) {
        DisplayObject._hitTestCanvas = canvas;
        DisplayObject._hitTestContext = canvas.getContext('2d');
        canvas.width = canvas.height = 1;
    }


    p._getStage = function () {

        var o = this, _Stage = createjs['Stage'];
        while (o.parent) {
            o = o.parent;
        }
        if (o instanceof _Stage) {
            return o;
        }
        return null;
    };


    p.getStage = createjs.deprecate(p._getStage, 'DisplayObject.getStage');


    try {
        Object.defineProperties(p, {
            stage: { get: p._getStage },
            cacheID: {
                get: function () { return this.bitmapCache && this.bitmapCache.cacheID; },
                set: function (a) { this.bitmapCache && (this.bitmapCache.cacheID = a); },
            },
            scale: {
                get: function () { return this.scaleX; },
                set: function (scale) { this.scaleX = this.scaleY = scale; },
            },
        });
    } catch (e) {
    }


    p.isVisible = function () {
        return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);
    };


    p.draw = function (ctx, ignoreCache) {
        var cache = this.bitmapCache;
        if (cache && !ignoreCache) {
            return cache.draw(ctx);
        }
        return false;
    };


    p.updateContext = function (ctx) {
        var o = this, mask = o.mask, mtx = o._props.matrix;

        if (mask && mask.graphics && !mask.graphics.isEmpty()) {
            mask.getMatrix(mtx);
            ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);

            mask.graphics.drawAsPath(ctx);
            ctx.clip();

            mtx.invert();
            ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
        }

        this.getMatrix(mtx);
        var tx = mtx.tx, ty = mtx.ty;
        if (DisplayObject._snapToPixelEnabled && o.snapToPixel) {
            tx = tx + (tx < 0 ? -0.5 : 0.5) | 0;
            ty = ty + (ty < 0 ? -0.5 : 0.5) | 0;
        }
        ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, tx, ty);
        ctx.globalAlpha *= o.alpha;
        if (o.compositeOperation) {
            ctx.globalCompositeOperation = o.compositeOperation;
        }
        if (o.shadow) {
            this._applyShadow(ctx, o.shadow);
        }
    };


    p.cache = function (x, y, width, height, scale, options) {
        if (!this.bitmapCache) {
            this.bitmapCache = new createjs.BitmapCache();
        } else {
            this.bitmapCache._autoGenerated = false;
        }
        this.bitmapCache.define(this, x, y, width, height, scale, options);
    };


    p.updateCache = function (compositeOperation) {
        if (!this.bitmapCache) {
            throw 'cache() must be called before updateCache()';
        }
        this.bitmapCache.update(compositeOperation);
    };


    p.uncache = function () {
        if (this.bitmapCache) {
            this.bitmapCache.release();
            this.bitmapCache = undefined;
        }
    };


    p.getCacheDataURL = function () {
        return this.bitmapCache ? this.bitmapCache.getCacheDataURL() : null;
    };


    p.localToGlobal = function (x, y, pt) {
        return this.getConcatenatedMatrix(this._props.matrix).transformPoint(x, y, pt || new createjs.Point());
    };


    p.globalToLocal = function (x, y, pt) {
        return this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x, y, pt || new createjs.Point());
    };


    p.localToLocal = function (x, y, target, pt) {
        pt = this.localToGlobal(x, y, pt);
        return target.globalToLocal(pt.x, pt.y, pt);
    };


    p.setTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
        this.x = x || 0;
        this.y = y || 0;
        this.scaleX = scaleX == null ? 1 : scaleX;
        this.scaleY = scaleY == null ? 1 : scaleY;
        this.rotation = rotation || 0;
        this.skewX = skewX || 0;
        this.skewY = skewY || 0;
        this.regX = regX || 0;
        this.regY = regY || 0;
        return this;
    };


    p.getMatrix = function (matrix) {
        var o = this, mtx = matrix || new createjs.Matrix2D();
        return o.transformMatrix ? mtx.copy(o.transformMatrix) :
            (mtx.identity() && mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY));
    };


    p.getConcatenatedMatrix = function (matrix) {
        var o = this, mtx = this.getMatrix(matrix);
        while (o = o.parent) {
            mtx.prependMatrix(o.getMatrix(o._props.matrix));
        }
        return mtx;
    };


    p.getConcatenatedDisplayProps = function (props) {
        props = props ? props.identity() : new createjs.DisplayProps();
        var o = this, mtx = o.getMatrix(props.matrix);
        do {
            props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);


            if (o != this) {
                mtx.prependMatrix(o.getMatrix(o._props.matrix));
            }
        } while (o = o.parent);
        return props;
    };


    p.hitTest = function (x, y) {
        var ctx = DisplayObject._hitTestContext;
        ctx.setTransform(1, 0, 0, 1, -x, -y);

        this.draw(ctx, !(this.bitmapCache && !(this.bitmapCache._cacheCanvas instanceof WebGLTexture)));

        var hit = this._testHit(ctx);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, 2, 2);
        return hit;
    };


    p.set = function (props) {
        for (var n in props) {
            this[n] = props[n];
        }
        return this;
    };

    /**
     * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).
     * Objects that have been cached will return the bounds of the cache.
     *
     * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use
     * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
     * bounds.
     *
     * <table>
     *    <tr><td><b>All</b></td><td>
     *        All display objects support setting bounds manually using setBounds(). Likewise, display objects that
     *        have been cached using cache() will return the bounds of their cache. Manual and cache bounds will override
     *        the automatic calculations listed below.
     *    </td></tr>
     *    <tr><td><b>Bitmap</b></td><td>
     *        Returns the width and height of the {{#crossLink "Bitmap/sourceRect"}}{{/crossLink}} (if specified) or image,
     *        extending from (x=0,y=0).
     *    </td></tr>
     *    <tr><td><b>Sprite</b></td><td>
     *        Returns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified
     *        in the spritesheet data. See also {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}}
     *    </td></tr>
     *    <tr><td><b>Container</b></td><td>
     *        Returns the aggregate (combined) bounds of all children that return a non-null value from `getBounds()`.
     *    </td></tr>
     *    <tr><td><b>Shape</b></td><td>
     *        Does not currently support automatic bounds calculations. Use `setBounds()` to manually define bounds.
     *    </td></tr>
     *    <tr><td><b>Text</b></td><td>
     *        Returns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height)
     *        are not, especially when using {{#crossLink "Text/textBaseline:property"}}{{/crossLink}} values other than "top".
     *    </td></tr>
     *    <tr><td><b>BitmapText</b></td><td>
     *        Returns approximate bounds. Values will be more accurate if spritesheet frame registration points are close
     *        to (x=0,y=0).
     *    </td></tr>
     * </table>
     *
     * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and
     * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the
     * bounds explicitly:
     *
     *    var bounds = obj.getBounds();
     *    obj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
     *    // getBounds will now use the set values, instead of recalculating
     *
     * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
     * values if you need to retain it.
     *
     *    var myBounds = obj.getBounds().clone();
     *    // OR:
     *    myRect.copy(obj.getBounds());
     *
     * @method getBounds
     * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this
     * object.
     **/
    p.getBounds = function () {
        if (this._bounds) {
            return this._rectangle.copy(this._bounds);
        }
        var cache = this.bitmapCache;
        if (cache && this.cacheCanvas) {
            return cache.getBounds();
        }
        return null;
    };

    /**
     * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).
     * Objects that have been cached will return the transformed bounds of the cache.
     *
     * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use
     * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
     * bounds.
     *
     * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
     * values if you need to retain it.
     *
     * Container instances calculate aggregate bounds for all children that return bounds via getBounds.
     * @method getTransformedBounds
     * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.
     **/
    p.getTransformedBounds = function () {
        return this._getBounds();
    };

    /**
     * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &
     * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always
     * override calculated bounds.
     *
     * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance
     * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).
     * @method setBounds
     * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.
     * @param {Number} y The y origin of the bounds.
     * @param {Number} width The width of the bounds.
     * @param {Number} height The height of the bounds.
     **/
    p.setBounds = function (x, y, width, height) {
        if (x == null) {
            this._bounds = x;
            return;
        }
        this._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);
    };

    /**
     * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are
     * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements
     * are copied by reference (masks, individual filter instances, hit area)
     * @method clone
     * @return {DisplayObject} A clone of the current DisplayObject instance.
     **/
    p.clone = function () {
        return this._cloneProps(new DisplayObject());
    };

    /**
     * Returns a string representation of this object.
     * @method toString
     * @return {String} a string representation of the instance.
     **/
    p.toString = function () {
        return '[DisplayObject (name=' + this.name + ')]';
    };


// private methods:
    /**
     * Called before the object gets drawn and is a chance to ensure the display state of the object is correct.
     * Mostly used by {{#crossLink "MovieClip"}}{{/crossLink}} and {{#crossLink "BitmapText"}}{{/crossLink}} to
     * correct their internal state and children prior to being drawn.
     *
     * Is manually called via draw in a {{#crossLink "Stage"}}{{/crossLink}} but is automatically called when
     * present in a {{#crossLink "StageGL"}}{{/crossLink}} instance.
     *
     * @method _updateState
     * @protected
     * @default null
     */
    p._updateState = null;

    // separated so it can be used more easily in subclasses:
    /**
     * @method _cloneProps
     * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject
     * instance copied into.
     * @return {DisplayObject} o
     * @protected
     **/
    p._cloneProps = function (o) {
        o.alpha = this.alpha;
        o.mouseEnabled = this.mouseEnabled;
        o.tickEnabled = this.tickEnabled;
        o.name = this.name;
        o.regX = this.regX;
        o.regY = this.regY;
        o.rotation = this.rotation;
        o.scaleX = this.scaleX;
        o.scaleY = this.scaleY;
        o.shadow = this.shadow;
        o.skewX = this.skewX;
        o.skewY = this.skewY;
        o.visible = this.visible;
        o.x = this.x;
        o.y = this.y;
        o.compositeOperation = this.compositeOperation;
        o.snapToPixel = this.snapToPixel;
        o.filters = this.filters == null ? null : this.filters.slice(0);
        o.mask = this.mask;
        o.hitArea = this.hitArea;
        o.cursor = this.cursor;
        o._bounds = this._bounds;
        o._webGLRenderStyle = this._webGLRenderStyle;
        return o;
    };

    /**
     * @method _applyShadow
     * @protected
     * @param {CanvasRenderingContext2D} ctx
     * @param {Shadow} shadow
     **/
    p._applyShadow = function (ctx, shadow) {
        shadow = shadow || Shadow.identity;
        ctx.shadowColor = shadow.color;
        ctx.shadowOffsetX = shadow.offsetX;
        ctx.shadowOffsetY = shadow.offsetY;
        ctx.shadowBlur = shadow.blur;
    };

    /**
     * @method _tick
     * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
     * @protected
     **/
    p._tick = function (evtObj) {
        // because tick can be really performance sensitive, check for listeners before calling dispatchEvent.
        var ls = this._listeners;
        if (ls && ls['tick']) {
            // reset & reuse the event object to avoid construction / GC costs:
            evtObj.target = null;
            evtObj.propagationStopped = evtObj.immediatePropagationStopped = false;
            this.dispatchEvent(evtObj);
        }
    };

    /**
     * @method _testHit
     * @protected
     * @param {CanvasRenderingContext2D} ctx
     * @return {Boolean}
     **/
    p._testHit = function (ctx) {
        try {
            var hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;
        } catch (e) {
            if (!DisplayObject.suppressCrossDomainErrors) {
                throw 'An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.';
            }
        }
        return hit;
    };

    /**
     * @method _getBounds
     * @param {Matrix2D} matrix
     * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
     * @return {Rectangle}
     * @protected
     **/
    p._getBounds = function (matrix, ignoreTransform) {
        return this._transformBounds(this.getBounds(), matrix, ignoreTransform);
    };

    /**
     * @method _transformBounds
     * @param {Rectangle} bounds
     * @param {Matrix2D} matrix
     * @param {Boolean} ignoreTransform
     * @return {Rectangle}
     * @protected
     **/
    p._transformBounds = function (bounds, matrix, ignoreTransform) {
        if (!bounds) {
            return bounds;
        }
        var x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;
        mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);

        if (x || y) {
            mtx.appendTransform(0, 0, 1, 1, 0, 0, 0, -x, -y);
        } // TODO: simplify this.
        if (matrix) {
            mtx.prependMatrix(matrix);
        }

        var x_a = width * mtx.a, x_b = width * mtx.b;
        var y_c = height * mtx.c, y_d = height * mtx.d;
        var tx = mtx.tx, ty = mtx.ty;

        var minX = tx, maxX = tx, minY = ty, maxY = ty;

        if ((x = x_a + tx) < minX) {
            minX = x;
        } else if (x > maxX) {
            maxX = x;
        }
        if ((x = x_a + y_c + tx) < minX) {
            minX = x;
        } else if (x > maxX) {
            maxX = x;
        }
        if ((x = y_c + tx) < minX) {
            minX = x;
        } else if (x > maxX) {
            maxX = x;
        }

        if ((y = x_b + ty) < minY) {
            minY = y;
        } else if (y > maxY) {
            maxY = y;
        }
        if ((y = x_b + y_d + ty) < minY) {
            minY = y;
        } else if (y > maxY) {
            maxY = y;
        }
        if ((y = y_d + ty) < minY) {
            minY = y;
        } else if (y > maxY) {
            maxY = y;
        }

        return bounds.setValues(minX, minY, maxX - minX, maxY - minY);
    };

    /**
     * Indicates whether the display object has any mouse event listeners or a cursor.
     * @method _isMouseOpaque
     * @return {Boolean}
     * @protected
     **/
    p._hasMouseEventListener = function () {
        var evts = DisplayObject._MOUSE_EVENTS;
        for (var i = 0, l = evts.length; i < l; i++) {
            if (this.hasEventListener(evts[i])) {
                return true;
            }
        }
        return !!this.cursor;
    };

    createjs.DisplayObject = createjs.promote(DisplayObject, 'EventDispatcher');
}());
